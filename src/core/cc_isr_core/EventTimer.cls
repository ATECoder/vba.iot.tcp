VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "EventTimer"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
' This timer comes from <see href="https://github.com/sancarn/stdVBA/blob/master/src/stdTimer.cls"/>
' Module greatly inspired by Cristian Buse's SafeTimers:
'   https://github.com/cristianbuse/Excel-VBA-SafeTimers
'
' Inspirations used:
'   * Use of remote workbook
'   * Use of VBOM and simplified registry setting
'
' Comparison of SaveTimers-Native and EventTimer:
'   * EventTimer will not raise the Tick event while displaying MsgBox or InputBox, however SafeTimers will
'   * EventTimer will raise events while Edit mode is "Edit" or "Point", SafeTimers-Native do not.
'   * EventTimer uses COM events (specifically WorksheetChange), SafeTimers-Native uses direct COM calls as a communication mechanism
'   * EventTimer can be bound to <see cref="IRunnable"/> callback OR via event interop. SafeTimers-Native can only be hooked into with Module macro names
'
' Limitations:
'   * Neither set of timers raise events while debugging code.
'   * Neither set of timers will be called exactly when it needs to. There will be a little bit of error which may have to be corrected.
'
' Architecture:
'   When a timer is initialized it:
'     * Ensures VBOM is enabled
'     * Creates a `new Application` object and adds a workbook to this new application.
'     * Adds Timer code to this workbook and schedules this code to run with `xlApp.OnTime Now(), "MainLoop"`
'   Every time the timer loops
'     * A change to the remote workbook's worksheet is made
'     * In the original workbook we register to receive these events, and receive a `m_remoteWorkbook_SheetChange` event.
'     * Here we raise the event, and call the callback if supplied.
'   When this class is terminated
'     * It will also tell the remote workbook to close.

Option Explicit

'Set DEBUG_MODE to true if you want to see the remote workbook
#Const DEBUG_MODE = False

''' <summary>   The name of the timer module. </summary>
Const TIMER_MODULE As String = "TimerMain"

''' <summary>   The timer start method. </summary>
Const TIMER_START_CALL As String = "TimerMain.StartTimer"

''' <summary>   The timer stop method. </summary>
Const TIMER_STOP_CALL As String = "TimerMain.StopTimer"

''' <summary>   The timer pause method. </summary>
Const TIMER_PAUSE_CALL As String = "TimerMain.PauseTimer"

''' <summary>   The timer resume method. </summary>
Const TIMER_RESUME_CALL As String = "TimerMain.ResumeTimer"

''' <summary>   Called every time the timer loops. </summary>
Public Event Tick()

Private WithEvents m_remoteWorkbook As Workbook
Attribute m_remoteWorkbook.VB_VarHelpID = -1

Private m_callback As IRunnable

' true when the workbook begines closing
Private m_workbookClosing As Boolean

' the timer interval in milliseconds.
Private m_interval As Integer

'Create an instance of the timer
'@param {Long} Number of milliseconds to raise Tick Event between
'@param {ICallable=Nothing} <see cref="IRunnable"/> Callback object. Must contain a Run() method.
'@returns {EventTimer} The frequency isn't guaranteed but it will be as close as humanly possible.
Public Function Create(ByVal a_interval As Long, Optional ByVal a_callback As IRunnable = Nothing) As EventTimer
  Set Create = New EventTimer
  Call Create.ProtInit(a_interval, a_callback)
End Function

'Initialize module
'@param {Long} Number of milliseconds to raise Tick Event between
'@param {IRunnable} Optional Listener
Public Sub ProtInit(ByVal a_interval As Long, a_callback As IRunnable)
    
    m_interval = a_interval
    
    Set m_callback = a_callback
    If Not GetVBOM Then Call SetVBOM(True)
    Set m_remoteWorkbook = CreateRemoteWorkbook()
    If Not GetVBOM Then Call SetVBOM(False)
    
    ' inject the timer code into the timer module.
    
    Call InjectCode(m_remoteWorkbook, TIMER_MODULE, GetTimerCode(a_interval))

End Sub

'Create and return a remote workbook, close equivalent of generating a new thread, however these threads will be in sync (due to usage of COM events)
'@param {Boolean, True} to see the workbook if in debug mode
'@returns {Workbook} Remote Workbook object.
Private Function CreateRemoteWorkbook(Optional ByVal a_visibleWorkbook As Boolean = True) As Workbook
    
    Dim p_application As Application: Set p_application = New Application
    #If DEBUG_MODE Then
        p_application.Visible = a_visibleWorkbook
    #Else
        p_application.Visible = False
        p_application.ScreenUpdating = False
    #End If
    p_application.PrintCommunication = False
    p_application.DisplayAlerts = False
    Set CreateRemoteWorkbook = p_application.Workbooks.Add

End Function

'Inject VBA code into a workbook
'@param {Workbook} The workbook to inject code into
'@param {string} The module name to create
'@param {ByRef string} The code to insert into the module
'@param {Long} The type of code module to create (Module=1, Class=2)
Public Sub InjectCode(ByVal a_workbook As Workbook, ByVal a_moduleName As String, _
        ByRef a_code As String, Optional ByVal a_moduleType As Long = 1)
  With a_workbook.VBProject.VBComponents.Add(a_moduleType).CodeModule
    If .CountOfLines > 0 Then .DeleteLines 1, .CountOfLines
    .AddFromString a_code
    .Parent.name = a_moduleName
  End With
End Sub

'Check if VB Object model is extensible
'@returns {Boolean} True if VBE Is Extensible (i.e. checked within the IDE, rather than the registry)
Private Function GetVBOM() As Boolean
  On Error Resume Next
  GetVBOM = Not Application.VBE.ActiveVBProject Is Nothing
End Function

'Check whether a registry key exists
'@param {Boolean} True to enable VBOM, False otherwise
'@returns {Boolean} True if key exists, False otherwise
'@author [Cristian Buse](https://github.com/cristianbuse)
Private Function SetVBOM(ByVal a_newValue As Boolean) As Boolean
  
  Dim i As Long: i = IIf(a_newValue, 1, 0)
  #If Mac Then
    Shell "defaults write com.microsoft.Excel AccessVBOM -int " & i
    SetVBOM = True
  #Else
    Dim p_registeryKey As String
    p_registeryKey = "HKEY_CURRENT_USER\Software\Microsoft\Office\" & Application.Version _
          & "\" & Replace(Application.name, "Microsoft ", vbNullString) _
          & "\Security\AccessVBOM"
    On Error Resume Next
    CreateObject("WScript.Shell").RegWrite p_registeryKey, i, "REG_DWORD"
    SetVBOM = (Err.Number = 0)
    On Error GoTo 0
  #End If

End Function

'Obtain code for a simple timer
Private Function GetTimerCode(ByVal a_interval As Long) As String
  
  Dim s As String: s = "' Auto-generated by EventTimer"
  s = s & vbCrLf & "#If Mac Then"
  s = s & vbCrLf & "  #If VBA7 Then"
  s = s & vbCrLf & "    Private Declare PtrSafe Sub USleep Lib ""/usr/lib/libc.dylib"" Alias ""usleep"" (ByVal a_microSecs As Long)"
  s = s & vbCrLf & "  #Else"
  s = s & vbCrLf & "    Private Declare Sub USleep Lib ""/usr/lib/libc.dylib"" Alias ""usleep"" (ByVal a_microSecs As Long)"
  s = s & vbCrLf & "  #End If"
  s = s & vbCrLf & "#Else 'Windows"
  s = s & vbCrLf & "  #If VBA7 Then"
  s = s & vbCrLf & "    Public Declare PtrSafe Sub Sleep Lib ""kernel32"" (ByVal a_milliSecs As Long)"
  s = s & vbCrLf & "  #Else"
  s = s & vbCrLf & "    Public Declare  Sub Sleep Lib ""kernel32"" Alias ""Sleep"" (ByVal a_milliSecs As Long)"
  s = s & vbCrLf & "  #End If"
  s = s & vbCrLf & "#End If"
  s = s & vbCrLf & "Private m_running as boolean"
  s = s & vbCrLf & "Private m_enabled as boolean"
  s = s & vbCrLf & "Sub MainLoop()"
  s = s & vbCrLf & "  While m_running"
  s = s & vbCrLf & "    If m_enabled Then"
  s = s & vbCrLf & "      Sheet1.Range(""A1"").Value = ""Tick"""
  s = s & vbCrLf & "    End If"
  s = s & vbCrLf & "    sleep " & a_interval
  s = s & vbCrLf & "    DoEvents"
  s = s & vbCrLf & "  Wend"
  s = s & vbCrLf & "  ThisWorkbook.Close false" 'cleanup
  s = s & vbCrLf & "End Sub"
  s = s & vbCrLf & "Sub StartTimer()"
  s = s & vbCrLf & "  m_enabled = true"
  s = s & vbCrLf & "  m_running = true"
  s = s & vbCrLf & "  Application.OnTime now(), ""MainLoop""" 'initialize main loop asynchronously
  s = s & vbCrLf & "End Sub"
  s = s & vbCrLf & "Sub PauseTimer()"
  s = s & vbCrLf & "  m_enabled = false"
  s = s & vbCrLf & "End Sub"
  s = s & vbCrLf & "Sub ResumeTimer()"
  s = s & vbCrLf & "  m_enabled = true"
  s = s & vbCrLf & "End Sub"
  s = s & vbCrLf & "Sub StopTimer()"
  s = s & vbCrLf & "  m_running = false"
  s = s & vbCrLf & "End Sub"
  GetTimerCode = s

End Function

''' <summary>   Handles the termination of this class. </summary>
''' <remarks>   On terminate, stop timer. This will cause workbook to close. </remarks>
Private Sub Class_Terminate()

    ' 20230704: this worked well.
    
    m_workbookClosing = False

    If Not m_remoteWorkbook Is Nothing Then
        
        ' this should also close the workbook
        
        Call m_remoteWorkbook.Application.Run(TIMER_STOP_CALL)
        
        ' wait for the timer interval to close.
        Dim stopper As New StopWatch
        Do Until stopper.ElapsedMilliseconds > m_interval Or m_workbookClosing
            DoEvents
        Loop
        
        If Not m_workbookClosing Then
          m_remoteWorkbook.Close False
        End If
        
    End If
    
    ' terminating the workbook does not see to close excel.
    Set m_remoteWorkbook = Nothing
    
End Sub

Private Sub m_remoteWorkbook_BeforeClose(Cancel As Boolean)
    m_workbookClosing = True
End Sub

''' <summary>   Handles the workbook sheet change event, which raises the <see cref="Tick"/>
''' event. </summary>
Private Sub m_remoteWorkbook_SheetChange(ByVal a_sender As Object, ByVal a_target As Range)
  RaiseEvent Tick
  If Not m_callback Is Nothing Then m_callback.Run
End Sub

''' <summary>   Starts the timer. </summary>
Public Sub StartTimer()
  Call m_remoteWorkbook.Application.Run(TIMER_START_CALL)
End Sub

''' <summary>   Stops the timer. </summary>
''' <remarks>   This also closes teh workbook. </remakrs>
Public Sub StopTimer()
  Call m_remoteWorkbook.Application.Run(TIMER_STOP_CALL)
End Sub

''' <summary>   Halts the timer. </summary>
Public Sub PauseTimer()
  Call m_remoteWorkbook.Application.Run(TIMER_PAUSE_CALL)
End Sub

''' <summary>   Resumes the timer. </summary>
Public Sub ResumeTimer()
  Call m_remoteWorkbook.Application.Run(TIMER_RESUME_CALL)
End Sub

